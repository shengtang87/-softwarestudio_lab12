{"version":3,"sources":["assets\\Script\\enemy.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import score from \"./score\";\r\n\r\nconst {ccclass, property} = cc._decorator;\r\n\r\n@ccclass\r\nexport default class enemy extends cc.Component \r\n{\r\n    private score: score = null;\r\n\r\n    private anim = null;\r\n\r\n    private collider = null;\r\n\r\n    private enemyManager = null;\r\n\r\n    private enemySpeed = 0;\r\n\r\n    public init(node: cc.Node)\r\n    {   \r\n        this.score = cc.find(\"Canvas/score\").getComponent(score);\r\n\r\n        this.anim = this.getComponent(cc.Animation);\r\n\r\n        this.collider = this.getComponent(cc.PhysicsBoxCollider);\r\n\r\n        this.node.opacity = 255;\r\n\r\n        this.setInitPos(node);\r\n\r\n        this.anim.play('enemy');\r\n    }\r\n\r\n    // this function is called when the enemy manager calls \"get\" API.\r\n    reuse(enemyManager)\r\n    {\r\n        this.enemyManager = enemyManager;\r\n    }\r\n\r\n    //this function sets the enemy's initial position when it is reused.\r\n    private setInitPos(node: cc.Node)\r\n    {\r\n        this.node.parent = node;\r\n\r\n        // I use random to decide where the enemy appear after reuse.\r\n        if(Math.random() > 0.5)\r\n        {\r\n            this.node.position = cc.v2(600, -110);\r\n\r\n            this.node.scaleX = 1;\r\n\r\n            this.enemySpeed = -200;\r\n\r\n            this.collider.enabled = true;\r\n\r\n            this.collider.offset = cc.v2(20, 0);\r\n\r\n            this.collider.apply();\r\n        }\r\n        else\r\n        {\r\n            this.node.position = cc.v2(-600, -110);\r\n\r\n            this.node.scaleX = -1;\r\n\r\n            this.enemySpeed = 200;\r\n\r\n            this.collider.enabled = true;\r\n\r\n            this.collider.offset = cc.v2(-20, 0);\r\n\r\n            this.collider.apply();\r\n        }\r\n    }\r\n\r\n    // check if current position is out of view.\r\n    private boundingDetect()\r\n    {\r\n        if(this.node.x > 650 || this.node.x < -650)\r\n            this.enemyManager.put(this.node);\r\n    }\r\n\r\n    //if this is called, the enemy will fade out in 1s and go back to the enemy pool.\r\n    private deadEffect()\r\n    {\r\n        this.enemySpeed = 0;\r\n\r\n        this.collider.enabled = false;\r\n\r\n        let fade = cc.fadeOut(1);\r\n\r\n        let finished = cc.callFunc(() => {\r\n            this.enemyManager.put(this.node);\r\n        });\r\n\r\n        this.node.runAction(cc.sequence(fade, finished));\r\n    }\r\n\r\n    update(dt)\r\n    {\r\n        this.node.x += this.enemySpeed * dt;\r\n\r\n        this.boundingDetect();\r\n    }\r\n\r\n    //check if the collision is valid or not, and call \"deadEffect\" if the collision is valid.\r\n    onBeginContact(contact, selfCollider, otherCollider)\r\n    {\r\n        if(otherCollider.node.name == \"bullet\" && !otherCollider.node.getComponent('Bullet').isTriggered)\r\n        {\r\n            otherCollider.node.getComponent('Bullet').isTriggered = true;\r\n\r\n            this.score.addOnePoint();\r\n\r\n            this.anim.stop();\r\n\r\n            this.deadEffect();\r\n        }\r\n    }\r\n}\r\n"]}